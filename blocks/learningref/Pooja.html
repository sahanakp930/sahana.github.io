<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures and Algorithms Summary</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            background-color: #030303;
            color: #212529;
            margin: 0;
            padding: 20px;
        }
       
        h1, h2, h3 {
            color: #007bff;
        }
        h1 {
            text-align: center;
            text-transform: uppercase;
            margin-bottom: 20px;
            color: #fefeff;
            background-color: #039311;
            padding: 10px;
            border-radius: 5px;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 2px solid #0f0f10;
            padding: 10px;
            background-color: #30da2d;
            border-radius: 4px;
            color: #020202;
        }
        h3 {
            margin-top: 20px;
            font-style: italic;
        }
        ul {
            list-style-type: disc;
            margin: 15px 20px;
        }
        li {
            margin-bottom: 8px;
        }
        code {
            background-color: #dfe6ed;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.95em;
        }
        p {
            margin: 15px 0;
        }
        strong {
            color: #343a40;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #d0f9bd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .note {
            font-size: 0.9em;
            background-color: #f8f9fa;
            border-left: 4px solid #6da4de;
            padding: 10px;
            margin-top: 10px;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 0.9em;
            color: #6a7077;
        }
    .navbar {
    position: sticky;
    top: 0;
    background-color:  #0c540e;
    width: 100%;
    z-index: 1000;
    padding: 0.5rem 1rem;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
    display: flex;
    border-radius: 10px;
    justify-content: center;
    justify-content: space-between;
  }

 
  
  .nav-list {
    list-style: none;
    display: flex;
    justify-content: space-around;
    align-content: center;
    margin: 0;
    padding: 0;
    
  }
  
  .nav-list li {
    margin: 0;
    color: #866545;
  }
  
  .nav-list a {
    text-decoration: none;
    color: #FB5235;
    align-content: center;
    padding: 1rem 1rem;
    transition: background-color 0.3s ease;
  }
  
  .nav-list a:hover {
    transform: scale(1.02);  
    background-color: #2fef2c;
   
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);  
    transition: transform 0.2s, box-shadow 0.2s;
    border-radius: 4px;
  }
  
  .content {
    padding: 2rem;
    font-size: 1.2rem;
    line-height: 1.6;
  }
    </style>
</head>
<body>
    <nav class="navbar">
        <ul class="nav-list">
            <li><a style="color:rgb(255, 255, 255)"  href="/sahana.github.io/blocks/home/home.html">Home</a></li>
            <li><a style="color:rgb(255, 255, 255)"  href="/sahana.github.io/index.html">PROJECT OVERVIEW</a></li>
            <li><a  style="color:rgb(253, 251, 251)" href="/sahana.github.io/blocks/learningref/teamlearning.html">Learning Reflections</a></li>
        </ul>
    </nav>
  <section>
    
        <h1>Data Structures and Algorithms </h1>
        <div class="container">
        <h2>1. Problems in Nature</h2>
        <ul>
            <li><strong>Iteration:</strong>: Solving problems using loops, real time example  climate change,school Schedules</li>
            <li><strong>Recursion:</strong>:Used to solve problems by breaking them into smaller subproblems of the same type,examples Ants Following Food,Weeds in a Garden</li>
            <li><strong>Backtracking:</strong>:Backtracking is a method of exploring all possible solutions and rejecting those that fail to satisfy constraints example Bees searching for flowers (pollination) ,Maze Solving.</li>
        </ul>
    </div>
    <h3></h3>
    <div class="container">
        <h2>2. Space and Time Efficiency</h2>
        <ul>
            <li><strong>Space Efficiency:</strong>Shows how quickly a task can be completed using an algorithm, especially when there’s a lot of data.</li>
            <li><strong>Time Efficiency:</strong> Shows how much memory an algorithm needs to complete its task.</li>
        </ul>
    
    
        <h3>Order of Growth:</h3>
        <ul>
            <li><code>O(1)</code> - Constant ,example: accessing one array index value </li>
            <li><code>O(n)</code> - Linear, example: traversing an array.</li>
            <li><code>O(n^3)</code> - Cubic</li>
            <li><code>O(log n)</code> - Logarithmic,example : Binary search</li>
            <li><code>O(n^2)</code> - Quadratic,example :Bubble sort</li>
            <li><code>O(n log n)</code> - Linearithmic </li>
            <li><code>O(n^k)</code> - Polynomial</li>
            <li><code>O(2^n)</code> - Exponential</li>
            <li><code>O(n!)</code> - Factorial</li>
        </ul>
        <div class="note">
            <p><strong>Best Case:</strong> Minimum time required under optimal conditions.</p>
            <p><strong>Average Case:</strong> Expected time over all possible inputs.</p>
            <p><strong>Worst Case:</strong> Maximum time required.</p>
        </div>
    </div>
        <h3></h3>
        <div class="container">
        <h2>3. Design Principles</h2>
        <p><ul>
            <li><strong>Divide and Conquer:</strong>
                Breaking the give data into smaller parts and solving them, and then combines the results. For example, in merge sort, we split the give data into smaller parts, sort them, and then combined.</li>
        </ul></p>
    </div>

    <h3></h3>
        <div class="container">
        <h2>4. Tree Data Structures</h2>
        <ul>
            <li><strong>BST (Binary Search Tree):</strong>A hierarchical tree structure where each item is placed to make searching, adding, and deleting faster. Left child &lt; root &lt; right child.</li>
            <li><strong>AVL:</strong> A hierarchical binary search tree that keeps itself balanced, by rotations to keep height balanced.</li>
            <li><strong>2-3 Tree:</strong> A variant of BST where nodes can have two or three children.</li>
            <li><strong>Red-Black Tree:</strong> A balanced binary tree where the root is always black, and red nodes have specific properties to maintain balance.</li>
            <li><strong>Heap:</strong>A hierarchical tree structure used to quickly find the highest or lowest priority data, like in a priority queue.</li>
            <li><strong>Trie:</strong> A tree-like structure used for storing words in a way that allows fast lookup based on prefixes.</li>
        </ul>
    </div>
    <h3></h3>
        <div class="container">
        <h2>5. Array Query Algorithms</h2>
        <p><ul>
            <li> Array in real-time applications they allow quick access to data,</li>
            <ul>
                <h4>Applications</h4>
            <li>Used to quickly calculate the sum of elements in a specific range of an array.</li>
            <li>Fenwick Trees:Used to efficiently calculate cumulative frequencies or sums</li></ul>
            <h4>Implications:</h4>
            <li> improve performance by reducing the time needed to process large amounts of data</li>
        </ul></p>
    </div>
    <h3></h3>
        <div class="container">
        <h2>6. Difference Between Tree and Graph Traversals</h2>
        <ul>
            <li><strong>Tree:</strong> A hirearchical data structure which has nodes connected by edges, acyclic, exactly n-1 edges for n nodes <h4>Traversal:</h4> 
                <ul><li>Preorder: rootnode-> leftnode->rightnode.</li>
                    <li>Postorder: leftnode->rightnode->rootnode </li>
                    <li>Inorder: leftnode->rootnode->rightnode</li>
                    
            </ul>
            </li>
            <li><strong>Graph:</strong> A data structure which has vertices connected by edges , they are cyclic , they can have any number of edges up to n(n-1)/2
                <h4>Traversal:</h4> 
                <ul><li>Breadth First Search(BFS)</li>
                    <li>Depth First Search(DFS)</li>

                </li>
        </ul>
        <h3>Applications:</h3>
        <ul>
            <li><strong>Tree:</strong> Hierarchical data, file systems,Phone Contact Lists.</li>
            <li><strong>Graph:</strong> Networks, Social Media Connections,,Navigation Apps,Online Shopping Recommendations:.</li>
        </ul>
    </div>
    <h3></h3>
        <div class="container">
        <h2>7. Sorting Algorithms</h2>
        <ul>
            <li><strong>Bubble Sort:</strong> Compares each pair of adjacent elements and swaps them if they’re in the wrong order, repeating this until the list is sorted.. (Time Complexity: <code>O(n^2)</code>)</li>
            <li><strong>Selection Sort:</strong> Finds the smallest element in the list and moves it to the correct position, then repeats the process with the remaining unsorted elements. (Time Complexity: <code>O(n^2)</code>)</li>
            <li><strong>Insertion Sort:</strong> Takes one element at a time and inserts it into its correct position within the already sorted part of the list.. (Time Complexity: <code>O(n^2)</code>)</li>
            <li><strong>Quick Sort:</strong>Select a value(pivote) from the data provided then find it's home ,then continue the same process till every element get it's home. (Time Complexity: <code>O(n log n)</code>)</li>
            <li><strong>Merge Sort:</strong> Divide the data into smaller parts, sorts them, and then merges them back together. (Time Complexity: <code>O(n log n)</code>)</li>
            <li><strong>Heap Sort:</strong> Builds a heap tree from the list and repeatedly removes the largest element to create a sorted list. (Time Complexity: <code>O(n log n)</code>)</li>
        </ul>
    </div>
        <h3></h3>
        <div class="container">
        <h2>8. Shortest Path Algorithms</h2>
        <ul>
            <li><strong>Dijkstra’s Algorithm:</strong> Finds the shortest path from one starting point to all other points in a graph, as long as all edge weights are positive.</li>
            <li><strong>Floyd’s Algorithm:</strong>Finds the shortest paths between all pairs of nodes in a graph, using a dynamic programming approach.</li>
            <li><strong>Bellman-Ford Algorithm:</strong>Finds the shortest paths from a starting point to all other points, even if some edges have negative weights.</li>
            <li><strong>Warshall’s Algorithm:</strong> Finds the shortest paths between all pairs of nodes in a graph, using a method that involves bitwise operations</li>
            <li><strong>Kruskal’s Algorithm:</strong> Creates a minimum spanning tree by adding the shortest edges one by one, making sure there are no cycles.</li>
            <li><strong>Prim’s Algorithm:</strong>Builds a minimum spanning tree starting from any node and adding the shortest edge from the tree to a new node.</li>
            <li><strong>Depth First Search Algorithm:</strong> used to trraverse a graph by starting at a node and visiting all its connected nodes, going as deep as possible before backtracking</li>
        </ul>
    </div>
    <h3></h3>
        <div class="container">
        <h2>9. Algorithm Design Techniques</h2>
        <ul>
            <li><strong>Divide and Conquer:</strong> Break a problem into smaller pieces, solve each piece, and then combine the results to get the final solution.</li>
            <li><strong>Brute Force:</strong> Try every possible solution and choose the best one.</li>
            <li><strong>Backtracking:</strong>Explore all possible solutions step by step, but if a solution fails, go back and try another path.</li>
            <li><strong>Recursion:</strong> Solve a problem by solving smaller versions of the same problem, repeating until base case.</li>
        </ul>
    </div>
  </section>
  <button onclick="window.history.back();" style="background-color: #0bb12f; color: rgb(241, 233, 233); border: none; padding: 10px 20px; font-size: 1rem; cursor: pointer; border-radius: 5px; margin-bottom: 20px;">Back</button>
</body>
