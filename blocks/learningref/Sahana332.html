<h2>Course Reflections</h2>

<h3>Member 1 - Sahana K.P</br>Roll number : 332</h3>


<p><strong>1. What are the kinds of problems we see in nature?</strong></p>
<p>Ans:<strong>Iteration:</strong>Involves Repetative process,Ex:the cells in our body repeatedly divide,climate always repetedly changes.<br><strong>Recursion:</strong>A function calls itself,Ex:single virus can produce many copies of it.<br><strong>Bactracting:</strong>While playing the game of chess backtracks on failure.</p>

<p><strong>2. What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.</strong></p>
<p>Ans:Extra space the algorithm requires is space efficiency.How fast an algorithm runs is time efficiency.Efficient algorithms save time and memory which is crucial for limited resources.
<br><strong>Classes of problems:</strong><br>1.Constant time:execution time does not depend on input time.
<br>2.Logarithmic time:execution time grows logarithmically with input size.
<br>3.Linear time:execution time grows linearly with input size.
<br>4.Linearithmic time:a combination of linear and logarithmic grows rates.
<br>5.Quadratic time:Execution time grows quadratically with input size.
<br>6.Exponential time:execution time doubles with each additional input unit.
<br>7.Factorial time:execution time grows factorially with input size.
<br><strong>Orders of growth:</strong><br>1.Constant time O(1):The runtime remains the same regardless of the input size.
<br>2.Logarithmic time O(logn): The runtime grows slowly, increasing logarithmically as the input size grows, often seen in binary search.
<br>3.Linear time O(n): The runtime increases proportionally to the input size, common in simple loops.
<br>4.Linearithmic time O(nlogn): The runtime grows faster than linear but slower than quadratic.
<br>5.Quadratic time O(n2): The runtime grows quadratically, often in nested loops.
<br>6.Cubic time O(n3): The runtime increases even more steeply that quadratic.
<br>7. Exponential time O(2n): The runtime grows exponentially, with each additional input, typical of brute-force solutions.
<br>8. Factorial time O(n!): The runtime grows extremely fast, seen in problems with extensive permutations.</p> 

<p><strong>3. Take away from different design principles from chapter 2</strong></p>
<p>Ans:</p>

<p><strong>4.The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, BST, AVL, 2-3, red-black, heap, trie)</strong></p>
<p>Ans:Hierarchical can be expressed in different ways,1 way is expressed in form of tree i,e n-array tree.It can be expressed in binary tree.
<br><strong>Binary search tree:</strong>It is created by taking first element as root ,less than root are towards left and greater than or equal are towards the right of tree.
<br><strong>AVL tree:</strong>AVL tree is balance version of binary tree ,In this we rotate in order to balance it.
<br><strong>2-3 tree:</strong>It has 2node or 3node.If the number of keys present in node equals 3 we promote middle key as parent and split remaining 2 children nodes.
<br><strong>red-black tree:</strong>Root inserted with black and every other node with red with no successive same colour allowed.
<br><strong>Heap:</strong>heap is defined by tree shape requirement and parental dominance.
<br><strong>Trie:</strong>It is tree like data structure where number of nodes of tree store alphabets and strings can be retrived by traversing down a branch path of tree.</p>

<p><strong>5. The need for array query algorithms and their implications. Their applications and principles need to be discussed.</strong></p>
<p>Ans:The need of array query algorithms is to quickly extract data and perform the operations faster.Searching through an unsorted list take lot of time.
<br><strong>Principles:</strong>1.Data Structures:The choice of data structures play a major role.<br>2.Divide and conquer:break the problem into smaller parts to solve it as we did in quick sort.<br>3.Transfer and conquer:A problem instance is transformed to one of the below before the solution is obtained.
<br><strong>Applications:They help search and sort data quickly in databases,make faster decisions in real time systems like traffic.</p>

<p><strong>6. Differentiate between tree and graphs and their traversals. The applications of each.</strong></p>
<p>Ans:<strong>Tree:</strong><br>1.tree have hierarchical structure.<br>2.They have no cycles.<br>application:binary search tree.<br><strong>Graph:</strong><br>1.graph have non hierarchical structure.<br>2.They have cycles.<br>application:computer networks.</p>

<p><strong>7. Deliberate on sorting and searching algorithms, the technique behind each and their connection to the real world.</strong></p>
<p>Ans:<strong>Bubble sort:</strong>In this we compare the swap elements.maximum element finds its home.<br><strong>Selection sort:</strong>In this we compare the swap elements.minimum element finds its home.<br><strong>Insertion sort:</strong>strong>In this we copy the element and then compare and swapping happens.<br><strong>Merge sort:</strong>We divide the elements into smaller parts and then merges them.<br><strong>Quick sort:</strong>strong>We use divide and conquer principle,divide the elements into larger or smaller groups and the sorts them.<br><strong>Linear search:</strong>strong>We search the target element sequentially.<br><strong>Binary search :</strong>strong>We sort the array and then divide it into half and search it.<br><strong>Real world connection:</strong>strong>Sorting and Searching are fundamental operations in database systems,operating systems,web search engines etc.</p>

<p><strong></strong>8.Discuss the importance of graph algorithms with respect to spanning trees and shortest path.</strong>s</p>
<p><strong>Ans:</br>Importance of Graph Algorithms:</br></strong>Graph algorithms are crucial for solving real-world problems that involve networks, connections, or relationships. Two key areas where graph algorithms are highly important are spanning trees and shortest paths.</br>
<strong>Spanning Trees:</br></strong>A spanning tree is a subgraph of a graph that includes all its nodes but only enough edges to form a tree (no cycles). The most common type is the Minimum Spanning Tree (MST), which minimizes the total weight of the edges.</br></br>
<strong>Why spanning trees are important..?</br></strong>Spanning trees are vital in network design, helping to create efficient communication or electrical networks at minimal cost, such as laying cables for internet or electricity while avoiding unnecessary expenses. They also aid in optimization by reducing redundant connections while ensuring the network remains fully operational. Additionally, spanning trees are used in clustering for machine learning and data analysis to group related data points effectively.</br>
<strong>Shortest Paths:</br></strong>Shortest path algorithms find the smallest possible distance or cost between two nodes in a graph. Examples include Dijkstra's Algorithm and Bellman-Ford Algorithm.</br>
<strong>Why shortest paths are important..?</strong></br>Shortest path algorithms are vital for navigation systems to find the fastest routes, network routing for efficient data flow, transportation to optimize deliveries and schedules, and game development for pathfinding in characters or objects.
</br><strong>Real-World Impact:</br></strong>Graph algorithms for spanning trees and shortest paths are essential in areas like transportation, communication, logistics, and even gaming. They provide efficient ways to design networks, reduce costs, and optimize processes, making them critical for modern technology and infrastructure.</br></br>
</p>

<p><strong>9.Discuss about the different studied algorithm design techniques.</strong>strong></p>
<p><strong>Ans:Divide and Conquer</br></strong>Divide and conquer breaks a problem into smaller parts, solves each part, and combines the results. Algorithms like Merge Sort, Quick Sort, and Binary Search use this method for efficient sorting and searching, making it ideal for data processing and computational tasks.</br>
<strong>Dynamic Programming :</br></strong>Dynamic programming solves overlapping subproblems and stores results to avoid repetition. It is used in algorithms like Matrix Chain Multiplication and Optimal Binary Search Tree, helping with optimization in resource allocation and scheduling.</br>
<strong>Greedy algorithm:</br></strong>Greedy algorithms make the best immediate choices to find an overall solution. They are used in Kruskal’s and Prim’s for minimum spanning trees and Dijkstra’s Algorithm for shortest paths, helping with network design and resource management.</br>
<strong>Backtracking:</br></strong>Backtracking explores all possible solutions, undoing steps when constraints are violated. It solves problems like N-Queens and is useful for puzzles, combinatorial problems, and constraint-based tasks like solving mazes.</br>
<strong>Branch and Bound:</br></strong>Branch and bound systematically explores and prunes unpromising options to solve optimization problems like Job Scheduling and Travelling Salesman Problem, commonly used in logistics and project planning.</br>
</p>
