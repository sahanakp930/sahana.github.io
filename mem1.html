<h2>Course Reflections</h2>

<h3>Member 1 - Sahana K.P</h3>

<p><strong>1. What are the kinds of problems we see in nature?</strong></p>
<p>
  <strong>Iteration:</strong> Involves a repetitive process. Example: The cells in our body repeatedly divide, and climate changes occur cyclically.<br>
  <strong>Recursion:</strong> A function calls itself. Example: A single virus can produce many copies of itself.<br>
  <strong>Backtracking:</strong> Example: While playing chess, the game backtracks when a move fails.
</p>

<p><strong>2. What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.</strong></p>
<p>
  <strong>Space Efficiency:</strong> Refers to the extra memory the algorithm requires.<br>
  <strong>Time Efficiency:</strong> Refers to how fast an algorithm runs.<br>
  Efficient algorithms save time and memory, which is crucial for limited resources.
  <br><br>
  <strong>Classes of Problems:</strong>
  <ul>
    <li><strong>Constant time:</strong> Execution time does not depend on input size.</li>
    <li><strong>Logarithmic time:</strong> Execution time grows logarithmically with input size.</li>
    <li><strong>Linear time:</strong> Execution time grows linearly with input size.</li>
    <li><strong>Linearithmic time:</strong> A combination of linear and logarithmic growth rates.</li>
    <li><strong>Quadratic time:</strong> Execution time grows quadratically with input size.</li>
    <li><strong>Exponential time:</strong> Execution time doubles with each additional input unit.</li>
    <li><strong>Factorial time:</strong> Execution time grows factorially with input size.</li>
  </ul>
  <strong>Orders of Growth:</strong>
  <ul>
    <li><strong>O(1):</strong> Constant time - runtime remains the same regardless of input size.</li>
    <li><strong>O(logn):</strong> Logarithmic time - runtime grows slowly, often seen in binary search.</li>
    <li><strong>O(n):</strong> Linear time - runtime increases proportionally to input size.</li>
    <li><strong>O(nlogn):</strong> Linearithmic time - faster than linear but slower than quadratic.</li>
    <li><strong>O(n²):</strong> Quadratic time - runtime grows quadratically, often seen in nested loops.</li>
    <li><strong>O(2ⁿ):</strong> Exponential time - runtime grows exponentially, typical in brute-force solutions.</li>
    <li><strong>O(n!):</strong> Factorial time - runtime grows extremely fast, often in problems with permutations.</li>
  </ul>
</p>

<p><strong>3. Takeaway from different design principles in Chapter 2:</strong></p>
<p>
  (It seems you missed answering this question! You might want to add your input here.)
</p>

<p><strong>4. The hierarchical data and how different tree data structures solve and optimize problem scenarios:</strong></p>
<p>
  Hierarchical data can be expressed in different ways, one of which is using trees (e.g., n-ary tree). A special case is the binary tree.<br>
  <strong>Binary Search Tree (BST):</strong> The first element is the root. Elements smaller than the root go to the left, and larger ones go to the right.<br>
  <strong>AVL Tree:</strong> A balanced version of the binary tree. Rotations are used to maintain balance.<br>
  <strong>2-3 Tree:</strong> Contains either 2-node or 3-node structures. When a node has three keys, the middle key is promoted as the parent, splitting the other keys into child nodes.<br>
  <strong>Red-Black Tree:</strong> A self-balancing tree where the root is always black, and no two consecutive red nodes are allowed.<br>
  <strong>Heap:</strong> Defined by tree shape requirements and parental dominance (max-heap or min-heap).<br>
  <strong>Trie:</strong> A tree-like data structure where nodes store alphabets, and strings are retrieved by traversing branches.
</p>

<p><strong>5. The need for array query algorithms, their applications, and principles:</strong></p>
<p>
  Array query algorithms are essential for quickly extracting data and performing operations efficiently. Searching through unsorted data is time-consuming.<br>
  <strong>Principles:</strong>
  <ul>
    <li><strong>Data Structures:</strong> The choice of data structures is crucial.</li>
    <li><strong>Divide and Conquer:</strong> Breaking problems into smaller parts, as in quicksort.</li>
    <li><strong>Transform and Conquer:</strong> Transforming problems into a simpler form before solving.</li>
  </ul>
  <strong>Applications:</strong> These algorithms speed up data search and sorting in databases and enable faster decisions in real-time systems like traffic management.
</p>

<p><strong>6. Differentiate between trees and graphs, their traversals, and applications:</strong></p>
<p>
  <strong>Tree:</strong>
  <ul>
    <li>Hierarchical structure.</li>
    <li>No cycles.</li>
    <li><strong>Applications:</strong> Binary Search Tree (BST).</li>
  </ul>
  <strong>Graph:</strong>
  <ul>
    <li>Non-hierarchical structure.</li>
    <li>May have cycles.</li>
    <li><strong>Applications:</strong> Computer networks.</li>
  </ul>
</p>

<p><strong>7. Sorting and searching algorithms, techniques, and their real-world connections:</strong></p>
<p>
  <strong>Sorting Algorithms:</strong>
  <ul>
    <li><strong>Bubble Sort:</strong> Compares and swaps adjacent elements until the largest element finds its correct position.</li>
    <li><strong>Selection Sort:</strong> Selects the smallest element and swaps it with the current index.</li>
    <li><strong>Insertion Sort:</strong> Copies an element, compares it with others, and inserts it into the correct position.</li>
    <li><strong>Merge Sort:</strong> Divides the array into smaller parts and merges them in sorted order.</li>
    <li><strong>Quick Sort:</strong> Uses divide-and-conquer to partition data into smaller and larger groups for sorting.</li>
  </ul>
  <strong>Searching Algorithms:</strong>
  <ul>
    <li><strong>Linear Search:</strong> Searches each element sequentially.</li>
    <li><strong>Binary Search:</strong> Divides the sorted array into halves to locate the target.</li>
  </ul>
  <strong>Real-World Applications:</strong> Sorting and searching are fundamental operations in database systems, operating systems, web search engines, etc.
</p>
