<h2>Course Reflections</h2>

<h3>Member 1 - Sahana K.P</h3>

<p><strong>1. What are the kinds of problems we see in nature?</strong></p>
<p>Ans:<strong>Iteration:</strong>Involves Repetative process,Ex:the cells in our body repeatedly divide,climate always repetedly changes.<br><strong>Recursion:</strong>A function calls itself,Ex:single virus can produce many copies of it.<br><strong>Bactracting:</strong>While playing the game of chess backtracks on failure.</p>

<p><strong>2. What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.</strong></p>
<p>Ans:Extra space the algorithm requires is space efficiency.How fast an algorithm runs is time efficiency.Efficient algorithms save time and memory which is crucial for limited resources.
<br><strong>Classes of problems:</strong><br>1.Constant time:execution time does not depend on input time.
<br>2.Logarithmic time:execution time grows logarithmically with input size.
<br>3.Linear time:execution time grows linearly with input size.
<br>4.Linearithmic time:a combination of linear and logarithmic grows rates.
<br>5.Quadratic time:Execution time grows quadratically with input size.
<br>6.Exponential time:execution time doubles with each additional input unit.
<br>7.Factorial time:execution time grows factorially with input size.
<br><strong>Orders of growth:</strong><br>1.Constant time O(1):The runtime remains the same regardless of the input size.
<br>2.Logarithmic time O(logn): The runtime grows slowly, increasing logarithmically as the input size grows, often seen in binary search.
<br>3.Linear time O(n): The runtime increases proportionally to the input size, common in simple loops.
<br>4.Linearithmic time O(nlogn): The runtime grows faster than linear but slower than quadratic.
<br>5.Quadratic time O(n2): The runtime grows quadratically, often in nested loops.
<br>6.Cubic time O(n3): The runtime increases even more steeply that quadratic.
<br>7. Exponential time O(2n): The runtime grows exponentially, with each additional input, typical of brute-force solutions.
<br>8. Factorial time O(n!): The runtime grows extremely fast, seen in problems with extensive permutations.</p> 

<p><strong>3. Take away from different design principles from chapter 2</strong></p>
<p>Ans:</p>

<p><strong>4.The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, BST, AVL, 2-3, red-black, heap, trie)</strong></p>
<p>Ans:Hierarchical can be expressed in different ways,1 way is expressed in form of tree i,e n-array tree.It can be expressed in binary tree.
<br><strong>Binary search tree:</strong>It is created by taking first element as root ,less than root are towards left and greater than or equal are towards the right of tree.
<br><strong>AVL tree:</strong>AVL tree is balance version of binary tree ,In this we rotate in order to balance it.
<br><strong>2-3 tree:</strong>It has 2node or 3node.If the number of keys present in node equals 3 we promote middle key as parent and split remaining 2 children nodes.
<br><strong>red-black tree:</strong>Root inserted with black and every other node with red with no successive same colour allowed.
<br><strong>Heap:</strong>heap is defined by tree shape requirement and parental dominance.
<br><strong>Trie:</strong>It is tree like data structure where number of nodes of tree store alphabets and strings can be retrived by traversing down a branch path of tree.</p>

<p><strong>5. The need for array query algorithms and their implications. Their applications and principles need to be discussed.</strong></p>
<p>Ans:The need of array query algorithms is to quickly extract data and perform the operations faster.Searching through an unsorted list take lot of time.
<br><strong>Principles:</strong>1.Data Structures:The choice of data structures play a major role.<br>2.Divide and conquer:break the problem into smaller parts to solve it as we did in quick sort.<br>3.Transfer and conquer:A problem instance is transformed to one of the below before the solution is obtained.
<br><strong>Applications:They help search and sort data quickly in databases,make faster decisions in real time systems like traffic.</p>

<p><strong>6. Differentiate between tree and graphs and their traversals. The applications of each.</strong></p>
<p>Ans:Tree:
<br>1.tree have hierarchical structure.
<br>2.They have no cycles.
<br>application:binary search tree.
<br>Graph:
<br>1.graph have non hierarchical structure.
<br>2.They have cycles.
<br>application:computer networks.</p>

<p><strong>7. Deliberate on sorting and searching algorithms, the technique behind each and their connection to the real world.</strong></p>
<p>Ans:<br>Bubble sort:In this we compare the swap elements.maximum element finds its home.
<br>Selection sort:In this we compare the swap elements.minimum element finds its home.
<br>Insertion sort:>In this we copy the element and then compare and swapping happens.
<br>Merge sort:We divide the elements into smaller parts and then merges them.
<br>Quick sort:We use divide and conquer principle,divide the elements into larger or smaller groups and the sorts them.
<br>Linear search:We search the target element sequentially.
<br>Binary search :We sort the array and then divide it into half and search it.
<br>Real world connection:Sorting and Searching are fundamental operations in database systems,operating systems,web search engines etc.</p>
